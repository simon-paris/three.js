<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<base href="../../../" />
		<script src="list.js"></script>
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		[page:Mesh] &rarr;

		<h1>[name]</h1>

		<p class="desc">
			Class representing a Mesh on which a WebGL2 occlusion query will be run. Occlusion queries are a WebGL2 feature that wraps a draw call,
			and asynchronously returns whether any samples generated by the draw call passed the depth test. You can use occlusion queries with any geometry and any material
			(including invisible materials) as long as depthTest is enabled.
			<br/><br/>
			Use this to determine visibility of regions or objects in your scene. A typical use is 'portal culling', where an invisible box shaped OcclusionQueryMesh
			is created on each doorway of an interior scene, and when the player looks at a doorway, the query will
			return positive, and you know to render the room that the doorway connects to. If the player is neither in a given room nor looking at it's doorway, you don't have to render the room.
			<br/><br/>
			Occlusion queries are dispatched whenever an OcclusionQueryMesh is rendered. ArrayCameras, shadows, frustum culling, multi-pass rendering,
			and the maxAliveQueries property can cause more or less than one query to be dispatched per frame.
			<br/><br/>
			Occlusion query results are polled immediently before a new query might be dispatched, or at the end of the frame if a
			new query wouldn't be dispatched, or manually (while not rendering a frame) using the pollQueries method or the pollAllOcclusionQueries method.
			The user defined callback is called every time a query is polled.
			<br/><br/>
			This is a WebGL2 feature, using it in a WebGL1 context will cause an error.
		</p>


		<h2>Example</h2>

		<code>
		// very expensive model that we want to avoid rendering if it's behind a wall
		var mesh = new THREE.Mesh( myVeryExpensiveGeometry, myVeryExpensiveShader );

		// make an occlusion query mesh out of a box that surrounds the expensive model
		var bounds = new Box3().expandByObject( mesh );
		var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
		var material = new THREE.MeshBasicMaterial( { color: 0xffffff, depthWrite: false, colorWrite: false } ); // invisible material
		var queryMesh = new THREE.OcclusionQueryMesh( geometry, material );
		bounds.getCenter( queryMesh.position );
		bounds.getSize( queryMesh.scale );
		var highestFrame = 0;
		queryMesh.occlusionQueryCallback = function ( result, frame, camera ) {

			// hide the expensive mesh if the occlusion query is negative
			if ( camera === myMainCamera && frame > highestFrame ) {
				mesh.visible = result;
				highestFrame = frame;
			}

		};

		queryMesh.frustumCulled = false;
		queryMesh.renderOrder = -1;

		scene.add( queryMesh );
		scene.add( mesh );
		</code>

		<h2>Interactions with other features</h2>

		<p>
			Shadow maps can do occlusion queries too. As with regular Meshes, the OcclusionQueryMesh is only rendered in the shadow map if it's a shadowCaster.
			The shadow camera will be passed to the callback. A true result from a shadow map occlusion query doesn't mean the shadow is visible to the player, it means
			the shadow caster is visible to the shadow camera. The depthWrite and colorWrite properties of the shadow shader are both set to the
			OcclusionQueryMesh's material's colorWrite property (i.e. Invisible OcclusionQueryMeshes have invisible shadows).
			<br/><br/>
			Frustum culling causes OcclusionQueryMeshes to not be rendered, just like regular Meshes. Therefore the callback will not be called.
			You're free to manually do the frustum check every frame, or just disable frustum culling on the OcclusionQueryMesh. Frustum culling applies to shadows too.
			<br/><br/>
			The overrideMaterial parameter of WebGLRenderer.render works as per normal. Invisible occlusion query meshes will become visible if you use this feature.
			<br/><br/>
			WebVR (ArrayCamera) causes one occlusion query to be dispatched per camera. Each eye camera will be passed to the callback so you can tell
			which eye can see which OcclusionQueryMesh. The ArrayCamera itself is not passed to the callback.
			<br/><br/>
			Do not use multi-materials on OcclusionQueryMeshes.
		</p>


		<h2>Constructor</h2>

		<h3>[name]( [param:Geometry geometry], [param:Material material] )</h3>
		<p>
		[page:Geometry geometry] — (optional) an instance of [page:Geometry] or [page:BufferGeometry].
		  Default is a new [page:BufferGeometry].<br />
		[page:Material material] — (optional) a single or an array of [page:Material]. Default is a new [page:MeshBasicMaterial]
		</p>


		<h2>Properties</h2>
		<p>See the base [page:Mesh] class for common properties.</p>

		<h3>[property:Function occlusionQueryCallback]</h3>
		<p>
		This callback is called whenever a query is polled. The function should take:
		<ul>
			<li>result - true if the any pixels were rendered, false otherwise</li>
			<li>frame - the frame number on which the query was dispatched</li>
			<li>camera - the camera used to render the object</li>
		</ul>
		Default null.
		</p>

		<h3>[property:Array cameraFilter]</h3>
		<p>
		An array of cameras. Cameras not in the array will be ignored for occlusion queries, but the mesh is still rendered.
		An empty array disables the occlusion query feature. Null means all cameras run the query. Default null.
		</p>

		<h3>[property:Boolean maxAliveQueries]</h3>
		<p>
		The maximum number of simultanious pending queries for this mesh per camera. New queries are not dispatched if the number of
		alive queries is greater than or equal to this property. Default 1.
		</p>


		<h2>Methods</h2>
		<p>See the base [page:Mesh] class for common methods.</p>

		<h3>[method:null pollQueries]( )</h3>
		<p>
		Check all the alive queries for this Mesh immediently. This is useful if you're rendering a new frame only when your scene changes.
		Calling this during rendering is not useful as alive queries will be polled automatically.
		<br/><br/>
		Don't call this in a loop, it won't work. Browsers cache query results until control returns to the event loop.
		</p>

		<h3>[method:null dispose]( )</h3>
		<p>
		Release the query status tracking data and WebGLQuery objects ascociated with this object.
		</p>

		<h2>Source</h2>

		[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
	</body>
</html>
